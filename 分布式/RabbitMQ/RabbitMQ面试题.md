1、消息队列的作用与使用场景?    
2、多个消费者监听一个生产者时，消息如何分发?     
3、无法被路由的消息，去了哪里?     
4、消息在什么时候会变成Dead Letter(死信)?     
5、RabbitMQ如何实现延迟队列?     
6、如何保证消息的可靠性投递?     
7、如何保证消息的幂等性?     
8、如何在服务端和消费端做限流?     
9、如何保证消息的顺序性?    


### 1、消息队列的作用与使用场景?   
总结：**异步、削峰、解耦、广播。**
1. 异步：

    批量数据异步处理
    如：批量上传文件
2. 削峰：

    高负载任务负载均衡
    如：电商秒杀抢购
3. 解耦：

    串行任务并行化
    如：退货流程解耦
4. 广播：

    基于发布/订阅模型实现一对多通信

### 2、多个消费者监听一个生产者时，消息如何分发?  
1. Round-Robin（轮询）

    #### 基本信息    
    轮流给消费者发送消息。  
    如：有三个消费者，消息队列中有9条消息。     
    consumer1会消费第1、4、7条消息，consumer2会消费第2、5、8条消息...
    | 消费者    | 消费的消息顺序 |
    | --------- | -------------- |
    | consumer1 | 1、4、7        |
    | consumer2 | 2、5、8        |
    | consumer3 | 3、6、9        |

    #### 带来问题
    1、不同消息消费的时长是不一样的。   

    ```java
    如：消息1、7处理的时间是比较长的，那么会导致consumer1处理的时间很长
    ```
    2、不一样的消费者消费消息速度是不一样的。

        如：consumer3的机器性能很差，导致处理时间变长

    会导致：**一些消费者一直很繁忙，一些消费者一直很空闲**。

2. Fair dispatch（公平分发）

    限制每个channel最大未响应消息数。
    ```java
     channel.basicQos(2); // 如果超过2条消息没有发送ACK，当前消费者不再接受队列消息
     channel.basicConsume(QUEUE_NAME, false, consumer);
    ```

### 3、无法被路由的消息，去了哪里?
如果没有任何的设置，那么该消息会直接被丢弃。    
解决方案：
1.  使用mandatory=true 配合 ReturnListener，实现消息回发。
2.  声明交换机时，指定备份交换机。


### 4、消息在什么时候会变成Dead Letter(死信)?  
1. 什么是Dead Letter？     
    当队列的消息到达了死信交换机中，该消息才能称为死信消息。
2. 什么时候会到达死信交换机?
    1.  消息被拒绝
        消息被消费者拒绝接受（单条拒绝/批量拒绝），并且requeue(重新入队列)设置为false;
    2.  消息过期
        1.  到达队列设置的过期时间
        2.  发送消息时，可以单独设置消息的过期时间
    3.  队列里发生了消息堆积
        队列可以指定x-max-length(最大消息数量或者最大字节)，如果队列中的消息大于该值，那么先进队列的消息会进入死信队列
3. 接收死信消息       
    可以设置一个死信队列(Dead Letter Queue)与DLX绑定，即可以存储Dead Letter，消费者可以监听这个队列取走消息。
    ```java
     Map<String,Object> arguments = new HashMap<String,Object>(); arguments.put("x-dead-letter-exchange","DLX_EXCHANGE");
    // 指定了这个队列的死信交换机
    channel.queueDeclare("TEST_DLX_QUEUE", false, false, false, arguments);
    // 声明死信交换机
    channel.exchangeDeclare("DLX_EXCHANGE","topic", false, false, false, null); // 声明死信队列
    channel.queueDeclare("DLX_QUEUE", false, false, false, null);
    // 绑定
    channel.queueBind("DLX_QUEUE","DLX_EXCHANGE","#");
    ```


### 5、RabbitMQ如何实现延迟队列? 
如：生产者发送一条消息，想要消费者在30分钟或者一小时后再消费该消息。    
RabbitMQ本身是不支持延迟队列的。所以我们需要进行另外的操作
1.  使用RabbitMQ的插件
2.  结合消息过期时间 和 死信队列    
    1.  生产者发送一条消息到一个没有消费者的队列，并指定消息过期时间x-dead-letter-exchange
    2.  到了过期时间，由于没有消费者，消息会进入死信队列
    3.  创建死信队列绑定死信交换机，消费端可以从死信队列中取走消息，从而实现延迟队列。



### 6、如何保证消息的可靠性投递? 
详见：[RabbitMQ保证消息的可靠性投递](http://note.youdao.com/noteshare?id=a2cecafb4748d5e1ee108750da746492)



### 7、如何保证消息的幂等性?
我们会采取消息重发的机制，来保证消息的可靠性投递。  
这样会产生重复发送消息的情况，消费者处理后没有发送应答，那么会产生消息的重复处理。  
1.  在生产者发送消息时可以指定唯一的messageID
2.  在消息的正文内，指定消息的业务ID，比如交易流水号
3.  在消费端中可以建表来记录处理消息的记录


### 8、如何在服务端和消费端做限流?  
RabbitMQ没有消费端接收了N条消息后，就不接收的功能。
1.  消费端采取内存和磁盘控制        
    RabbitMQ默认内存占用40%，磁盘空间小于1G后就不接收消息。
2.  采取prefetch count来限制    
    改队列中存在N条未处理消息，则不再接收新消息
3.  采取网关和接入层


### 9、如何保证消息的顺序性?
在RabbitMQ中如果一个消息队列，有多个消费者，那么消息顺序性是没有办法得到保证的。    
只有在一个队列，只有一个消费者，消息顺序才可以保证。    
或者可以通过全局ID方式来实现    

1.  发消息时为消息指定一个msgID，相同批次的消息指定一个parentMsgID
2.  在消费端接收消息时，如果前一条消息没有被处理，那么就不处理该条消息
3.  在生产端，如果前一条消息没有得到响应，那么就不发送下一条消息